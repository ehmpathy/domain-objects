import { UnexpectedCodePathError } from 'helpful-errors';
import { omit } from 'type-fns';

import { assertDomainObjectIsSafeToManipulate } from '@src/constraints/assertDomainObjectIsSafeToManipulate';
import type { DomainObject } from '@src/instantiation/DomainObject';
import { isOfDomainObject } from '@src/instantiation/inherit/isOfDomainObject';

import { getMetadataKeys } from './getMetadataKeys';

/**
 * exposes a function which properly handles any value that can could have been defined for an object property
 * - if domain object, omits metadata values
 * - if array, recursively omits on each item in the array
 * - if neither of the above, then its the terminal condition - return it, its fully omitted
 */
const recursivelyOmitMetadataFromObjectValue: any = (thisValue: any) => {
  // handle directly nested domain object
  if (isOfDomainObject(thisValue)) return omitMetadata(thisValue); // eslint-disable-line @typescript-eslint/no-use-before-define

  // handle an array of one level deep (doesn't handle Array of Array, for simplicity)
  if (Array.isArray(thisValue))
    return thisValue.map(recursivelyOmitMetadataFromObjectValue); // run self on each item in the array, (i.e., recursively)

  // handle any other value type
  return thisValue;
};

/**
 * omits all metadata values on a domain object
 *
 * relevance:
 * - often in change detection, metadata values are not relevant, this provides an easy way to omit them
 *
 * features:
 * - utilizes the `.metadata` property of the domain object definition to identify metadata keys
 *   - recall, the default is `id`, `uuid`, `createdAt`, `updatedAt`, `effectiveAt`
 * - recursive, applies omission deeply
 *
 * note:
 * - metadata is the most common readonly category, applicable to all domain objects
 * - for broader readonly (including non-metadata externally-resolved attributes), use `omitReadonly`
 */
export const omitMetadata = <T extends DomainObject<Record<string, any>>>(
  obj: T,
): T => {
  // handle arrays
  if (Array.isArray(obj)) return recursivelyOmitMetadataFromObjectValue(obj);

  // make sure its an instance of DomainObject
  if (!isOfDomainObject(obj))
    throw new UnexpectedCodePathError(
      'omitMetadata called on object that is not an instance of a DomainObject. Are you sure you instantiated the object? (Related: see `DomainObject.nested`)',
      { obj },
    );

  // get the metadata keys
  const Constructor = obj.constructor as any as { new (...args: any): T }; // https://stackoverflow.com/a/61444747/3068233
  const metadataKeys = getMetadataKeys(obj, {
    nameOfFunctionNeededFor: 'omitMetadata',
  });

  // make sure that its safe to manipulate
  assertDomainObjectIsSafeToManipulate(obj);

  // object with omit applied recursively on each property
  const objectWithEachDomainObjectKeyRecursivelyOmitted: typeof obj =
    Object.entries(obj).reduce(
      (summary, [thisKey, thisValue]) => {
        return {
          ...summary,
          [thisKey]: recursivelyOmitMetadataFromObjectValue(thisValue),
        };
      },
      {} as typeof obj,
    );

  // omit all of the metadata keys
  const objWithoutBaseCaseAutogeneratedValues = omit(
    objectWithEachDomainObjectKeyRecursivelyOmitted,
    metadataKeys as never,
  );

  // return the instantiated object
  return new Constructor(objWithoutBaseCaseAutogeneratedValues);
};
