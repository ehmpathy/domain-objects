# Research: TypeScript Constructor Type Inference from Instances

**Date**: 2025-11-23 15:45 PST
**Topic**: Can TypeScript infer constructor type (and static properties) from instance types?

## Summary

**Answer: No** - TypeScript still cannot automatically infer constructor static properties from instance types alone. This remains a fundamental limitation in TypeScript's type system as of 2024-2025.

## The Core Problem

TypeScript's type inference is **one-directional** when it comes to classes:

-  **Constructor ’ Instance**: TypeScript CAN infer instance types from constructors
  - Using `InstanceType<typeof Class>` extracts the instance type

- L **Instance ’ Constructor**: TypeScript CANNOT infer constructor types from instances
  - There's no built-in way to go from instance type back to constructor type
  - Static properties on the constructor are not accessible through instance types

## Why This Matters for `refByUnique` and `refByPrimary`

When implementing these procedures, we encounter this limitation:

```typescript
const turtle = new SeaTurtle({ uuid: '1', seawaterSecurityNumber: '821', name: 'Crush' });
const ref = refByUnique(turtle);
```

In this code:
- `turtle` has type `SeaTurtle` (the instance type)
- `SeaTurtle.unique = ['seawaterSecurityNumber']` is a **static property** on the **constructor**
- TypeScript's type system doesn't maintain a connection between instance types and their constructor's static members
- Therefore, TypeScript cannot automatically infer `typeof SeaTurtle` from just the instance `turtle`

## Technical Explanation

### What TypeScript Knows

```typescript
class SeaTurtle extends DomainEntity<SeaTurtle> {
  public static primary = ['uuid'] as const;
  public static unique = ['seawaterSecurityNumber'] as const;

  uuid?: string;
  seawaterSecurityNumber: string;
  name: string;
}
```

A class declaration creates **two separate things**:
1. **Instance side**: The type representing instances (e.g., `SeaTurtle`)
2. **Static side**: The constructor function with static members (e.g., `typeof SeaTurtle`)

### The Inference Gap

```typescript
// What we want to work:
function refByUnique<TInstance extends DomainObjectShape>(
  instance: TInstance,
): TInstance extends InstanceType<infer TDobj>
  ? TDobj extends Refable<infer TShape, infer TPrimary, infer TUnique>
    ? DomainUniqueKeyShape<TDobj, TShape, TPrimary, TUnique>
    : never
  : never;

// Problem: TypeScript cannot infer TDobj from TInstance
// Because TInstance only contains instance type information,
// not constructor type information
```

The conditional type `TInstance extends InstanceType<infer TDobj>` fails because:
- `TInstance` is the instance type (e.g., `SeaTurtle`)
- `InstanceType<T>` expects a constructor type as input, not an instance type
- There's no inverse operation to extract the constructor type from an instance type

## Attempted Solutions

### 1. Conditional Type Inference (Failed)

```typescript
export function refByUnique<TInstance extends DomainObjectShape>(
  instance: TInstance,
): TInstance extends InstanceType<infer TDobj>
  ? TDobj extends Refable<infer TShape, infer TPrimary, infer TUnique>
    ? DomainUniqueKeyShape<TDobj, TShape, TPrimary, TUnique>
    : never
  : never {
  // Returns 'never' type - inference fails
}
```

**Result**: Returns `never` because the conditional type cannot infer the constructor.

### 2. Runtime Constructor Access (Works at Runtime, Not in Types)

```typescript
const DomainObjectConstructor = (instance as any).constructor;
const uniqueKeys = DomainObjectConstructor?.unique; //  Works at runtime
```

**Result**: This works at **runtime** but doesn't help with **type inference**. TypeScript's type system operates at compile time and cannot use runtime information.

## Current Best Practice: Explicit Generic

The accepted solution in the TypeScript community is to require explicit generic type parameters:

```typescript
//  Correct approach - explicitly provide the constructor type
const ref = refByUnique<typeof SeaTurtle>(turtle);
```

This is the same pattern used throughout the ecosystem, including in the existing `getReferenceTo` function in this codebase.

## Evidence from Research

### Stack Overflow Discussions

1. **[Infer constructor type in TypeScript](https://stackoverflow.com/questions/55866473/infer-constructor-type-in-typescript)**
   - Confirms that TypeScript "intentionally does not allow you to infer the type of the constructor parameters from the type of an instance"
   - This is a known limitation, not a missing feature

2. **[Get a class (static) property from an instance](https://stackoverflow.com/questions/42633015/get-a-class-static-property-from-an-instance)**
   - Shows that at runtime you can use `(instance.constructor as typeof Class)`
   - But this doesn't help with type inference

3. **[How to get the type of a static property on a TypeScript class?](https://stackoverflow.com/questions/58339244/how-to-get-the-type-of-a-static-property-on-a-typescript-class)**
   - Demonstrates that you need `typeof Class` to access static property types
   - Cannot be derived from instance types alone

### Official TypeScript Documentation

**[TypeScript: Documentation - Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)**
- Explains the separation between instance side and static side of classes
- Shows that `typeof` is required to reference the constructor type

## Existing Pattern in Codebase

This limitation is already acknowledged in the codebase:

```typescript
// From src/reference/getReferenceTo.ts
/**
 * declares a reference to a domain.entity or domain.event
 *
 * note
 * - if the shape of the unique and primary keys are not resolved, please manually annotate the type
 *   - e.g., `const ref = getRef<typeof SeaTurtle>(turtle)` instead of `const ref = getRef(turtle)`
 *   - automatic resolution of the relationship between instance and class.static properties is still a todo
 */
```

This comment from the existing code confirms that automatic resolution is a known limitation.

## Conclusion

**The implementation requiring explicit generics is correct and follows TypeScript best practices.**

```typescript
// Required pattern (works correctly):
const ref = refByUnique<typeof SeaTurtle>(turtle);
const ref = refByPrimary<typeof SeaTurtle>(turtle);
```

This limitation exists because:
1. TypeScript's type system separates instance types from constructor types
2. Static properties exist only on the constructor, not on instances
3. There's no way to infer the constructor type from an instance type
4. This is an intentional design decision in TypeScript, not a bug

Future TypeScript versions may improve this, but as of 2024-2025, explicit generic parameters remain necessary.

## Sources

- [Infer constructor type in TypeScript - Stack Overflow](https://stackoverflow.com/questions/55866473/infer-constructor-type-in-typescript)
- [TypeScript: Documentation - Classes](https://www.typescriptlang.org/docs/handbook/2/classes.html)
- [How to infer type information from constructor input parameters? - Stack Overflow](https://stackoverflow.com/questions/64668752/typescript-how-to-infer-type-information-from-constructor-input-parameters)
- [How to get the type of a static property on a TypeScript class? - Stack Overflow](https://stackoverflow.com/questions/58339244/how-to-get-the-type-of-a-static-property-on-a-typescript-class)
- [Get a class (static) property from an instance - Stack Overflow](https://stackoverflow.com/questions/42633015/get-a-class-static-property-from-an-instance)
- [TypeScript: Accessing Static Properties from an Instance](https://www.xjavascript.com/blog/typescript-access-static-property-from-instance/)
- [A Deep Dive into TypeScript's infer Keyword - DEV Community](https://dev.to/leapcell/a-deep-dive-into-typescripts-infer-keyword-1o4b)
