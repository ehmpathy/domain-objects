given a case where we have a dobj with nested refs

e.g.,


```ts
  interface SeaTurtle {
    uuid?: string;
    seawaterSecurityNumber: string;
    name: string;
  }
  class SeaTurtle extends DomainEntity<SeaTurtle> implements SeaTurtle {
    public static primary = ['uuid'] as const;
    public static unique = ['seawaterSecurityNumber'] as const;
  }


  interface SeaTurtleShell {
    turtle: Ref<typeof SeaTurtle>;
    algea: "ALOT" | "ALIL"
  }
  class SeaTurtleShell extends DomainEntity<SeaTurtleShell> implements SeaTurtleShell {
    public static unique = ['turtle']
  }
```


then if we call

```ts
const turtle = SeaTurtle.as({
  seawaterSecurityNumber: "821",
  name: "Crush",
})
const shell = SeaTurtleShell.as({
  turtle,
  algea: "ALIL",
})
const ref = refByUnique<typeof SeaTurtleShell>(shell)
```

it will recursively `refByUnique` when it detects a nested DomainEntity
