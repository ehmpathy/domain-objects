# Blueprint: Clarifying @readonly vs @metadata in domain-objects

## Context

The wish is to make the distinction between `@readonly` and `@metadata` more clear:

Both are set by the persistence layer, but they differ in what they describe:

- **@metadata**: A special subset of readonly - attributes that describe the **persistence** of the object (e.g., `id`, `uuid`, `createdAt`, `updatedAt`, `effectiveAt`). Applicable to **all domain objects**.
- **@readonly**: The broader category - includes metadata plus **intrinsic attributes** of the object that the persistence layer sets. Applicable only to **DomainEntity** (not DomainEvent or DomainLiteral).

**Key insight: `metadata` is a subset of `readonly`** - all metadata properties are readonly, but not all readonly properties are metadata.

**Why only DomainEntity for explicit readonly?**
- **DomainEvent**: Immutable by nature. All properties are known before persistence - no persistence-layer-set intrinsic attributes.
- **DomainLiteral**: Value objects fully defined by intrinsic properties. If a property changes, it's a different literal.

| Type | Applies To | What it Describes | Example |
|------|------------|---------|---------|
| `metadata` | All domain objects | Persistence of the object | `id`, `uuid`, `createdAt` |
| `readonly` | DomainEntity only | Intrinsic attributes set by persistence | `host`, `port`, `status` from AWS |

---

## Proposed Changes

### 1. Update `metadata` description in DomainObject to clarify relationship with readonly

**File:** `src/instantiation/DomainObject.ts`

Update the existing `metadata` static property description to clarify that metadata is a common type of readonly:

```typescript
/**
 * DomainObject.metadata
 *
 * When set, customizes the keys that are considered as metadata of this domain object.
 *
 * Metadata is a common type of readonly attribute - identity assigned by the persistence
 * layer (e.g., database id, uuid, timestamps). Unlike intrinsic readonly attributes
 * (only applicable to entities/events), metadata applies to all domain objects.
 *
 * @see DomainEntity.readonly - for broader readonly attributes on entities
 * @see DomainEvent.readonly - for broader readonly attributes on events
 */
public static metadata: readonly string[];
```

---

### 2. Add `readonly` static property to DomainEntity only

**File:** `src/instantiation/DomainEntity.ts`

Add a new static property (NOT on DomainObject base class or DomainEvent):

```typescript
/**
 * DomainEntity.readonly
 *
 * Defines intrinsic domain attributes that are set by the persistence layer.
 *
 * Both metadata and readonly are set by the persistence layer, but they differ:
 * - metadata describes the persistence of the object (e.g., id, uuid, createdAt)
 * - readonly (non-metadata) describes intrinsic attributes of the object
 *
 * Note: metadata is a special subset of readonly. This property is for non-metadata readonly.
 *
 * Note: only DomainEntity supports explicit readonly keys, not DomainEvent or DomainLiteral.
 * - DomainEvent: immutable by nature, all properties known before persistence
 * - DomainLiteral: value objects fully defined by intrinsic properties
 *
 * @example
 * // For an AWS RDS cluster:
 * public static readonly = ['host', 'port', 'status'] as const;
 */
public static readonly: readonly string[];
```

**Note:** No default values for `readonly` - unlike `metadata` which has sensible defaults, readonly properties are domain-specific and must be explicitly declared.

**Why not on DomainEvent?** Events are immutable by nature. All properties are known before persistence - there's no concept of persistence-layer-set intrinsic attributes.

**Why not on DomainLiteral?** Literals are value objects fully defined by intrinsic properties. If a value changes, it's a different literal.

---

### 3. Implement `getReadonlyKeys()` function

**File:** `src/manipulation/getReadonlyKeys.ts` (new file)

```typescript
import { DomainObject } from '../instantiation/DomainObject';
import { isOfDomainEntity } from '../instantiation/inherit/isOfDomainEntity';
import { isOfDomainEvent } from '../instantiation/inherit/isOfDomainEvent';
import { isOfDomainLiteral } from '../instantiation/inherit/isOfDomainLiteral';
import { getMetadataKeys } from './getMetadataKeys';

/**
 * .what = gets the keys that are marked as readonly on a domain object
 * .why = enables omitting externally-resolved values that shouldn't be user-settable
 *
 * .note = metadata is a common type of readonly applicable to all domain objects
 * .note = broader readonly (non-metadata) is only applicable to DomainEntity and DomainEvent
 */
export const getReadonlyKeys = (obj: DomainObject<any>): string[] => {
  // metadata is always readonly (applicable to all domain objects)
  const metadataKeys = getMetadataKeys(obj);

  // for DomainLiteral, only metadata is readonly (literals are fully defined by intrinsic properties)
  if (isOfDomainLiteral(obj)) return metadataKeys;

  // for DomainEntity and DomainEvent, include both metadata and explicit readonly keys
  if (isOfDomainEntity(obj) || isOfDomainEvent(obj)) {
    const domainObjectConstructor = obj.constructor as any;
    const explicitReadonlyKeys = domainObjectConstructor.readonly ?? [];
    // combine and dedupe
    return [...new Set([...metadataKeys, ...explicitReadonlyKeys])];
  }

  // fallback: just metadata
  return metadataKeys;
};
```

**Key design decision:** `getReadonlyKeys()` returns the **union** of metadata keys and explicit readonly keys, since metadata is a subset of readonly.

---

### 4. Implement `omitReadonly()` function

**File:** `src/manipulation/omitReadonly.ts` (new file)

Pattern after `omitMetadataValues.ts`:

```typescript
import { DomainObject } from '../instantiation/DomainObject';
import { isOfDomainObject } from '../instantiation/inherit/isOfDomainObject';
import { assertDomainObjectIsSafeToManipulate } from '../constraints/assertDomainObjectIsSafeToManipulate';
import { getReadonlyKeys } from './getReadonlyKeys';
import { omit } from 'type-fns';

/**
 * .what = recursively omits readonly values from a domain object
 * .why = enables comparison/submission of only user-settable values
 */
export const omitReadonly = <T extends DomainObject<T>>(obj: T): T => {
  // Validate input
  if (!isOfDomainObject(obj))
    throw new Error('omitReadonly only works on DomainObjects');

  // Assert safe to manipulate
  assertDomainObjectIsSafeToManipulate(obj);

  // Recursively process nested values
  const processedObj = Object.keys(obj).reduce((acc, key) => {
    const value = (obj as any)[key];
    return {
      ...acc,
      [key]: recursivelyOmitReadonlyFromValue(value),
    };
  }, {} as Record<string, any>);

  // Omit readonly keys
  const readonlyKeys = getReadonlyKeys(obj);
  const withoutReadonly = omit(processedObj, readonlyKeys);

  // Reinstantiate to preserve class type
  const domainObjectConstructor = obj.constructor as new (props: any) => T;
  return new domainObjectConstructor(withoutReadonly);
};

const recursivelyOmitReadonlyFromValue = (value: any): any => {
  if (isOfDomainObject(value)) return omitReadonly(value);
  if (Array.isArray(value)) return value.map(recursivelyOmitReadonlyFromValue);
  return value;
};
```

---

### 5. Rename `omitMetadataValues` to `omitMetadata`

For consistency between `omitMetadata` and `omitReadonly`:

**Step 5a:** Create new `omitMetadata.ts` file with the same implementation

**Step 5b:** Update `omitMetadataValues.ts` to re-export with deprecation notice:

```typescript
import { omitMetadata } from './omitMetadata';

/**
 * @deprecated Use `omitMetadata` instead. Will be removed in next major version.
 */
export const omitMetadataValues = omitMetadata;
```

**Step 5c:** Update exports in `src/index.ts`:

```typescript
export { omitMetadata } from './manipulation/omitMetadata';
export { omitMetadataValues } from './manipulation/omitMetadataValues'; // deprecated re-export
export { getReadonlyKeys } from './manipulation/getReadonlyKeys';
export { omitReadonly } from './manipulation/omitReadonly';
```

---

### 6. Update README documentation

Add a new section explaining the distinction:

```markdown
## Readonly vs Metadata Properties

Domain objects support two categories of readonly properties. **Metadata is the most common readonly category** - all metadata is readonly, but not all readonly is metadata.

### Metadata Properties (Common Readonly - All Domain Objects)

**Metadata** are identity attributes assigned by the persistence layer - information
*about* the object, not intrinsic attributes *of* the object. This is the most common
type of readonly property and applies to **all domain objects** (entities, events, and literals).

- Default metadata keys: `id`, `uuid`, `createdAt`, `updatedAt`, `effectiveAt`
- Customize via `static metadata = ['...'] as const;`
- Omit with `omitMetadata(obj)`

```typescript
class User extends DomainEntity<User> implements User {
  public static primary = ['id'] as const;
  public static unique = ['email'] as const;
  public static metadata = ['id', 'createdAt', 'updatedAt'] as const;
}
```

### Readonly Properties (Broader Category - Entities & Events Only)

**Readonly** is the broader category encompassing all externally-resolved attributes.
Beyond metadata, some domain entities and events have intrinsic attributes that are
resolved from an external source of truth (e.g., AWS API, external service).

- Only applicable to **DomainEntity and DomainEvent** (not DomainLiteral)
- No default readonly keys (domain-specific, must be explicitly declared)
- Declare via `static readonly = ['...'] as const;`
- Omit with `omitReadonly(obj)` - this omits **both** metadata AND explicit readonly keys

**Why not DomainLiteral?** Literals are value objects fully defined by their intrinsic
properties. If a property changes, it's a different literal - there's no concept of
externally-resolved attributes that persist across the same literal identity.

```typescript
class AwsRdsCluster extends DomainEntity<AwsRdsCluster> implements AwsRdsCluster {
  public static primary = ['arn'] as const;
  public static unique = ['name'] as const;
  public static metadata = ['arn'] as const;                    // AWS-assigned identity (readonly)
  public static readonly = ['host', 'port', 'status'] as const; // AWS-resolved attributes (also readonly)
}
```

### Key Distinction

| Aspect | Metadata | Readonly (broader) |
|--------|----------|----------|
| Relationship | A special **subset of** readonly | The **superset** containing metadata + more |
| Applies to | All domain objects | DomainEntity only |
| What it describes | Persistence of the object | Intrinsic attributes of the object |
| Set by | Persistence layer | Persistence layer |
| Default keys | Yes (`id`, `uuid`, etc.) | No (explicit only) |
| Omit function | `omitMetadata()` | `omitReadonly()` (includes metadata) |
```

---

## File Changes Summary

| Action | File |
|--------|------|
| Modify | `src/instantiation/DomainObject.ts` - update `metadata` description to clarify relationship with readonly |
| Modify | `src/instantiation/DomainEntity.ts` - add `readonly` static property |
| Create | `src/manipulation/getReadonlyKeys.ts` |
| Create | `src/manipulation/getReadonlyKeys.test.ts` |
| Create | `src/manipulation/omitReadonly.ts` |
| Create | `src/manipulation/omitReadonly.test.ts` |
| Create | `src/manipulation/omitMetadata.ts` (renamed implementation) |
| Modify | `src/manipulation/omitMetadataValues.ts` (deprecation wrapper) |
| Modify | `src/index.ts` - add new exports |
| Modify | `readme.md` - add documentation section |

**Note:** DomainEvent does NOT get a `readonly` property - events are immutable by nature.

---

## Test Cases to Implement

### `getReadonlyKeys.test.ts`

1. Returns empty array when no readonly defined
2. Returns declared readonly keys when defined
3. Works with DomainEntity
4. Works with DomainLiteral
5. Works with DomainEvent

### `omitReadonly.test.ts`

1. Omits readonly values from flat domain object
2. Preserves non-readonly values
3. Recursively omits from nested domain objects
4. Handles arrays of domain objects
5. Returns instance of original class
6. Works when no readonly keys defined (returns unchanged)
7. Works with schema validation

---

## Backward Compatibility

- `omitMetadataValues` remains exported with deprecation notice
- Existing `metadata` behavior unchanged
- `readonly` is opt-in; existing code unaffected
- No breaking changes; can be released as minor version
